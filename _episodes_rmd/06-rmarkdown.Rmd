---
title: "Getting started with R Markdown"
teaching: 25
exercises: 20
output: 
  html_document:
    df_print: paged
objectives:
- Create a .Rmd document containing R code, text, and plots
- Create a YAML header to control output
- Understand basic syntax of (R)Markdown
- Customise code chunks to control formatting
- Use code chunks and in-line code to create dynamic documents
- Understand how R Markdown can be used to create reproducible reports
keypoints: R Markdown is a popular language for creating reproducible reports, articles, and theses.
source: Rmd
questions:
- What is R Markdown?
- How can I integrate my R code with text and plots?
- How can I convert .Rmd files to .html, .pdf, and .docx?
---

```{r setup, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("06-")
source("../bin/download_data.R")
```

## R Markdown

R Markdown is a flexible type of document that allows you to seamlessly combine 
executable R code, and its output, with text in a single document. These documents
can be readily converted to multiple static and dynamic output formats, including
PDF (.pdf), Word (.docx), and HTML (.html).

![https://github.com/allisonhorst](../fig/rmarkdown_wizards.png)

The benefit of a well-prepared R Markdown document is full reproducibility. This
also means that, if you notice a data transcription error, or you are able to add 
more data to your analysis, you will be able to recompile the report with the new
data, without making any changes in the actual document.

## Creating an R Markdown file

To create a new R Markdown document in RStudio, click File -> New File -> R Markdown:

![Screenshot of the New R Markdown file dialogue box in RStudio](../fig/new-rmd.png)

Then click on 'Create Empty Document'. Normally you could enter the title of your
document, your name (Author), and select the type of output, but we will be learning
how to start from a blank document.

## Basic components of R Markdown

To control the output, a YAML (originally, Yet Another Markup Language; now, YAML Ain't Markup Language)
header is needed.

```
---
title: "My Awesome Report"
author: "My Awesome Name"
date: ""
output: html_document
---
```

The only necessary field is the `output:`, which specifies the type of output you
want. The rest can be deleted if you don't need them. To start the document, 
we will begin writing below the YAML header (i.e. after the second `---`).

## Markdown syntax

Markdown is a popular markup language that allows you to add formatting elements
to text, such as **bold**, *italics*, and `code`. The formatting will not be
immediately visible in a markdown (.md) document, like in Word, rather you add
Markdown syntax to the text, which can then be converted to various other file 
that can translate the Markdown syntax. Markdown is useful because it is 
lightweight, flexible, and platform independent.

Some platforms provide a real time preview of the formatting, like RStudio's 
visual markdown editor (available from version 1.4).

First, let's create a header:

```
# Title
## Section
### Sub-section
#### Sub-sub section
##### Sub-sub-sub section
```

Since we have already defined our title in the YAML header, we will use a section
header.

```
## A meaningful header

Some meaningful text to go along with my meaningful header.
```

You can make things **bold** by surrounding the word with double asterisks, 
`**bold**`, or double underscores, `__bold__`; and *italicize* using single asterisks,
`*italics*`, or single underscores, `_italics_`.

You can also combine **bold** and *italics* to write something ***really*** 
important with triple-asterisks, `***really***`, or underscores, `___really___`;
and, if you're feeling bold (pun intended), you can also use a combination of
asterisks and underscores, **_really_**. Just be consistent...

To create `code-type` font, surround the word with backticks.

Now that we've learned a couple of things, it might be useful to create a list so
we don't forget:

```
- bold with double-asterisks
- italics with underscores
- code-type font with backticks
```

You can also create an ordered list using numbers:

```
1. bold with double-asterisks
2. italics with underscores
3. code-type font with backticks
```

And nested items by tab-indenting:

```
- bold with double-asterisks
  + or double-underscores
- italics with underscores
  + or double-asterisks
- bold and italics with triple-asterisks
  + or triple-underscores
    - or a combination of both
- code-type font with backticks
```

Now we can Knit the document into HTML by clicking the 'Knit' button in the top
of the Source pane (top left), or use the keyboard shortcut
<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>K</kbd> on Windows and Linux, or 
<kbd>Cmd</kbd>+<kbd>Shift</kbd>+<kbd>K</kbd> on Mac.

![The 'knitting' process](../fig/rmd-rmd_to_html.png)

For more Markdown syntax see [here](https://www.markdownguide.org/basic-syntax).

> ## Exercise
>
> Create a new blank R Markdown document and write a bit of Markdown 
> (some sections, some italicized text, and an itemized list).
>
> Convert the document to a webpage.
> > ## Solution
> >
> > In RStudio, select File > New file > R Markdown... 
> > 
> > Add the following:
> > 
> > ```
> > # Introduction
> > 
> > ## Background on Data
> > 
> > This report uses the *SAFI* dataset, which has columns that include:
> > 
> > - village
> > - interview_date
> > - no_members
> > - years_liv
> > - respondent_wall_type
> > - rooms
> > 
> > ## Background on Methods
> > 
> > ```
> > 
> > Then click the 'Knit' button on the toolbar to generate an HTML document.
> {: .solution}
{: .challenge}

## Writing an R Markdown report

We will be writing a report based on our previous data wrangling and visualisation,
which means we need to make sure **tidyverse** is loaded. It is not enough to
load **tidyverse** from the console, we will need to load it within our R Markdown
document. For that, we will need to create a 'code chunk' at the top of our document
(under the YAML header). The syntax of a code chunk is:

<pre>
&#96;&#96;&#96;{r chunk_name}
R code here
&#96;&#96;&#96;
</pre>

That is, between ```{r chunk_name} and ```, you place the R code you want to run.
Naming a chunk is optional, but recommended. Each chunk name must be unique, and
only contain alphanumeric characters, `-`, and `_`.

The keyboard shortcut for inserting a code chunk in RStudio is
<kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>I</kbd> on Windows and Linux, or
<kbd>Cmd</kbd>+<kbd>Option</kbd>+<kbd>I</kbd> on Mac.

To load **tidyverse**, we will insert a chunk and call it 'setup'. Since we don't
want to show the chunk or the output of the chunk, we use: 
`{r setup, include=FALSE}`. We will review more details about the chunk options
later.

```{r load-tidyverse, message=FALSE, purl=FALSE}
library(tidyverse)
```

We will also need the data we worked with earlier. If they are not still in the
workspace (check your Environment pane), load the data we saved in the previous
lesson by adding the following to the 'setup' chunk:

```{r load-data, message=FALSE, purl=FALSE}
library(tidyverse)
interviews <- read_csv("data/SAFI_clean.csv", na = "NULL")
```

### Insert table

Next, we will create a table with the first 10 entries and first 4 columns in the
interviews data frame. We can do this using the following code in a new chunk; 
let's call it 'interview-tbl_1', or you can come up with something more creative
(just remember to stick to the naming rules).

```{r interview-tbl_1, message=FALSE, purl=FALSE}
interviews %>%
  select(1:4) %>%
  slice_head(n = 10) # only show the first 10 rows
```

### Customising chunk output

There are multiple options available to customise how the code-chunks are presented
in the output document.

| Option | Output |
|---|---|
| `eval=<TRUE,FALSE>` | Whether or not the code within the code chunk should be run. |
| `echo=<TRUE,FALSE>` | Choose if you want to show your code chunk in the output document. `echo=TRUE` will show the code chunk. |
| `include=<TRUE,FALSE>` | Choose if the output of a code chunk should be included in the document. `FALSE` means that your code will run, but will not show up in the document. |

The options are entered in the code chunk after `chunk_name` and separated by
commas, e.g. `{r chunk_name, eval=FALSE, echo=TRUE}`.

> ## Notes
>
> - The default settings are: `eval=TRUE`, `echo=TRUE`, `include=TRUE`.
> - The default settings can be modified with `knitr::opts_chunk$set()`,
> - Entering `knitr::opts_chunk$set(echo = FALSE)` will change the default of
> value of `echo` to `TRUE` for all chunks in the document.

{: .callout}


> ## Exercise
>
> Play around with the different options in the chunk with the code for the table, 
> and re-Knit to see what each option does to the output.
>
> What happens if you use `eval=FALSE` and `echo=FALSE`? What is the difference between
> this and `include=FALSE`? 
> > ## Solution to Exercise
> > 
> > Create a chunk with `{r eval=FALSE, echo=FALSE}`, then create another chunk
> > with `{r include=FALSE}` to compare.
> > `eval=FALSE` and `echo=FALSE` will neither run the code in the chunk, nor show 
> > the code in the knitted document. The code chunk essentially doesn't exist in
> > the knitted document, 
> > whereas `include=FALSE` will run the code and store the output for later use.
> {: .solution}
{: .challenge}

<!-- Insert table with caption using `knitr::kable`. -->

### In-line R code

Now we will use some in-line R code to present some descriptive statistics.
To use in-line R-code, we use the backticks that we also used in the Markdown
section, but now we need to specify that we are using R-code. This is done by
including `r` after the first backtick. For example, today's date is `r Sys.Date()`.
Well, at least that was the date this document was last knitted. The in-line code 
used to do this is: 

<pre>
&#96;r Sys.Date()&#96;
</pre>

By including in-text R-code to present descriptive statistics (or test statistics),
it will be run each time we knit the document. Which means if, for whatever reason,
our data have changed, the document will automatically update the descriptive
statistics accordingly. Pretty useful for those of us who are prone to data entry
errors!

The best way to use in-line R code, is to minimise the amount of code you need
to produce the in-line output by preparing the output in code chunks. Let's say
we're interested in presenting the average household size in each village. 
We can modify some code from a previous episode:

```{r in-line-code, purl=FALSE}
mean_household <- interviews %>%
    group_by(village) %>%
    summarize(mean_no_membrs = mean(no_membrs))

# and separate the villages
mean_chirodzo <- mean_household %>%
  filter(village == "Chirodzo")
```

Now we can make an informative statement on the means of each village, and include
the mean values as in-line R-code, for example: 

The average household size in the village of Chirodzo is 
`r mean_chirodzo$mean_no_membrs`.

When, you knit your document, the code will be executed and the output will only
show the value produced by the code. In the source document you won't see the
value, only the code used to produce it:

<pre>
&#96;r mean_chirodzo$mean_no_members&#96;
</pre>

Because we are using in-line R code instead of the actual values, we have created
a dynamic document that will automatically update if we make changes to the original
dataset.

> ## Exercise
>
> Create a new code chunk for the plot, and copy the code from any of the plots 
> we created in the previous episode to produce a plot in the chunk. I recommend
> one of the colourful plots.
>
> > ## Solution to Exercise
> > ```{r my-plot, answer=TRUE, purl=FALSE}
> > interviews_plotting %>%
> >   ggplot(aes(x = respondent_wall_type)) +
> >   geom_bar(aes(fill = village))
> > ```
> {: .solution}
{: .challenge}

<!-- ordered example naming the villages with largest average household in decreasing order -->

### Plots

Finally, we will also include a plot, so our document is a little more colourful and
a little less boring. We will use the same data as we did in the previous episode.

If you were unable to complete the previous lesson or did not save the data,
then you can create it now.

```{r interview-plotting-data, purl = FALSE, eval = TRUE}
## Not run, but can be used to load in data from previous lesson!
interviews_plotting <- interviews %>%
  ## pivot wider by items_owned
  separate_rows(items_owned, sep = ";") %>%
  ## if there were no items listed, changing NA to no_listed_items
  replace_na(list(items_owned = "no_listed_items")) %>%
  mutate(items_owned_logical = TRUE) %>%
  pivot_wider(names_from = items_owned, 
              values_from = items_owned_logical, 
              values_fill = list(items_owned_logical = FALSE)) %>%
  ## pivot wider by months_lack_food
  separate_rows(months_lack_food, sep = ";") %>%
  mutate(months_lack_food_logical = TRUE) %>%
  pivot_wider(names_from = months_lack_food, 
              values_from = months_lack_food_logical, 
              values_fill = list(months_lack_food_logical = FALSE)) %>%
  ## add some summary columns
  mutate(number_months_lack_food = rowSums(select(., Jan:May))) %>%
  mutate(number_items = rowSums(select(., bicycle:car)))
```

> ## Exercise
>
> Create a new code chunk for the plot, and copy the code from any of the plots 
> we created in the previous episode to produce a plot in the chunk. I recommend
> one of the colourful plots.
>
> > ## Solution to Exercise
> > ```{r my-fancy-plot, answer=TRUE, purl=FALSE}
> > interviews_plotting %>%
> >   ggplot(aes(x = respondent_wall_type)) +
> >   geom_bar(aes(fill = village))
> > ```
> {: .solution}
{: .challenge}

We can also create a caption with the chunk option `fig.cap="caption here."`.
For example:

```{r caption-plot, purl=FALSE, fig.cap="I made this plot while attending an awesome datacarpentries workshop where I learned a ton of cool stuff!"}
interviews_plotting %>%
  ggplot(aes(x = respondent_wall_type)) +
  geom_bar(aes(fill = village)) +
  scale_fill_viridis_d() # add colourblind-friendly palette
```

...or something like that.

## Other cool things R Markdown can do

Websites with the **blogdown** package

Books with the **bookdown** package

Slides with the **xaringan** package

Article templates with the **rticles** package

## Resources

* [Knitr in a knutshell tutorial](http://kbroman.org/knitr_knutshell)
* [Dynamic Documents with R and knitr](http://www.amazon.com/exec/obidos/ASIN/1482203537/7210-20) (book)
* [R Markdown documentation](http://rmarkdown.rstudio.com)
* [R Markdown cheat sheet](https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf)
* [Getting started with R Markdown](https://www.rstudio.com/resources/webinars/getting-started-with-r-markdown/)
* [R Markdown: The Definitive Guide](https://bookdown.org/yihui/rmarkdown/) (book by Rstudio team)
* [Reproducible Reporting](https://www.rstudio.com/resources/webinars/reproducible-reporting/)
* [The Ecosystem of R Markdown](https://www.rstudio.com/resources/webinars/the-ecosystem-of-r-markdown/)
* [Introducing Bookdown](https://www.rstudio.com/resources/webinars/introducing-bookdown/)
